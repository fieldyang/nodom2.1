{"code":"import { Directive } from \"./directive\";\r\nimport { Element } from \"./element\";\r\nimport { NEvent } from \"./event\";\r\nimport { Expression } from \"./expression\";\r\nimport { PluginManager } from \"./pluginmanager\";\r\nimport { selfClosingTag } from \"./types\";\r\nimport { Util } from \"./util\";\r\nexport class Compiler {\r\n    /**\r\n    * 编译\r\n    * @param elementStr    待编译html串\r\n    * @returns             虚拟dom\r\n    */\r\n    static compile(elementStr) {\r\n        // 这里是把模板串通过正则表达式匹配 生成AST\r\n        let ast = this.compileTemplateToAst(elementStr);\r\n        // console.log(ast);\r\n        let oe = new Element('div');\r\n        // 将AST编译成抽象语法树\r\n        this.compileAST(oe, ast);\r\n        return oe;\r\n        // // 这里是使用游离的dom来充当ast的流程 暂时先保留着以便对比\r\n        // const div: HTMLElement = Util.newEl('div');\r\n        // try {\r\n        //     div.innerHTML = elementStr;\r\n        // } catch (e) { }\r\n        // let oe = new Element('div');\r\n        // this.handleChildren(oe, div);\r\n        // //保证模块只有一个根节点\r\n        // // if (oe.children.length === 1) {\r\n        // //     return oe.children[0];\r\n        // // }\r\n        // // console.log(oe);\r\n        // return oe;\r\n    }\r\n    /**\r\n     * 把AST编译成虚拟dom\r\n     * @param oe 虚拟dom的根容器\r\n     * @param ast 抽象语法树也就是JSON对象\r\n     * @returns oe 虚拟dom的根容器\r\n     */\r\n    static compileAST(oe, ast) {\r\n        // const div: HTMLElement = Util.newEl('div');\r\n        // let oe = new Element('div');\r\n        if (!ast)\r\n            return;\r\n        for (const a of ast) {\r\n            switch (a.tagName) {\r\n                case 'text': //文本节点\r\n                    this.handleAstText(oe, a);\r\n                    break;\r\n                case 'comment': // 注释不处理\r\n                    break;\r\n                default:\r\n                    if (a.tagName !== 'svg') {\r\n                        // let chlid = new Element(a.tagName);\r\n                        this.handleAstNode(oe, a);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        return oe;\r\n    }\r\n    /**\r\n     * 编译text类型的ast到虚拟dom\r\n     * @param parent 父虚拟dom节点\r\n     * @param ast 虚拟dom树\r\n     */\r\n    static handleAstText(parent, astObj) {\r\n        let text = new Element();\r\n        // 处理属性\r\n        this.handleAstAttrs(text, astObj.attrs);\r\n        // text 类型的节点不需要处理子节点。\r\n        text.expressions = astObj.expressions;\r\n        text.textContent = astObj.textContent;\r\n        parent.children.push(text);\r\n    }\r\n    /**\r\n     *\r\n     * @param oe 虚拟dom\r\n     * @param astObj\r\n     */\r\n    static handleAstNode(parent, astObj) {\r\n        let de = PluginManager.get(astObj.tagName.toUpperCase());\r\n        let child = new Element(astObj.tagName);\r\n        // 处理属性\r\n        this.handleAstAttrs(child, astObj.attrs);\r\n        this.compileAST(child, astObj.children);\r\n        if (de) {\r\n            parent.children.push(Reflect.construct(de, [child]).element);\r\n        }\r\n        else {\r\n            parent.children.push(child);\r\n        }\r\n    }\r\n    /**\r\n     * 编译ast 到虚拟dom\r\n     * @param oe 虚拟dom\r\n     * @param attrs 需要编译成虚拟dom的attrs\r\n     */\r\n    static handleAstAttrs(oe, attrs) {\r\n        //指令数组 先处理普通属性在处理指令\r\n        let directives = [];\r\n        if (!attrs) {\r\n            return;\r\n        }\r\n        for (const attr of attrs) {\r\n            if (attr.propName.startsWith(\"x-\")) {\r\n                //指令\r\n                directives.push(attr);\r\n            }\r\n            else if (attr.propName.startsWith(\"e-\")) {\r\n                // 事件\r\n                let e = attr.propName.substr(2);\r\n                oe.addEvent(new NEvent(e, attr.value.trim()));\r\n            }\r\n            else {\r\n                // 普通属性 如class 等\r\n                let isExpr = false;\r\n                let v = attr.value.trim();\r\n                if (v !== '') {\r\n                    let ra = this.compileExpression(v);\r\n                    if (Util.isArray(ra)) {\r\n                        oe.setProp(attr.propName, ra, true);\r\n                        isExpr = true;\r\n                    }\r\n                }\r\n                if (!isExpr) {\r\n                    oe.setProp(attr.propName, v);\r\n                }\r\n            }\r\n        }\r\n        //处理属性\r\n        for (let attr of directives) {\r\n            new Directive(attr.propName.substr(2), attr.value.trim(), oe, null, true);\r\n        }\r\n        if (directives.length > 1) {\r\n            //指令排序\r\n            oe.directives.sort((a, b) => {\r\n                return a.type.prio - b.type.prio;\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * 处理属性字符串\r\n     * @param attrString 属性字符串\r\n     * @returns attrs数组\r\n     */\r\n    static parseAttrString(attrString) {\r\n        if (attrString == undefined || attrString.length === 0)\r\n            return [];\r\n        attrString = attrString.trim();\r\n        //引号flag 当前是否在引号内\r\n        let yinhaoFlag = false;\r\n        // 断点\r\n        let point = 0;\r\n        let result = [];\r\n        for (let i = 0; i < attrString.length; i++) {\r\n            let s = attrString[i];\r\n            if (s == '\"') {\r\n                yinhaoFlag = !yinhaoFlag;\r\n            }\r\n            else if (s == \" \" && !yinhaoFlag) {\r\n                //遇到空格并且不在引号中\r\n                if (!/^\\s*?$/.test(attrString.substring(point, i))) {\r\n                    result.push(attrString.substring(point, i).trim());\r\n                    point = i;\r\n                }\r\n            }\r\n        }\r\n        let lastAttr = attrString.substring(point).trim();\r\n        // 判断最后一个属性是不是自定义标签的'/' 如果是则不把他当作标签。\r\n        if (lastAttr !== '/') {\r\n            //循环结束之后还剩一个属性没加进去，因为可能最后一个属性后面没有空格\r\n            result.push(attrString.substring(point).trim());\r\n        }\r\n        result = result.map((item) => {\r\n            // 如果match为空说明属性串里面没有“”也就是自定义的只有属性名没有属性值得属性，这种直接给他的value字段设置为空就行了\r\n            const o = item.match(/^(.+)=[\\'|\\\"](.+)[\\'|\\\"]$/) || [, item];\r\n            return {\r\n                propName: o[1],\r\n                value: o[2] ? o[2] : '',\r\n            };\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * 将模板字符串转换成AST抽象语法树结构\r\n     * @param elementStr 模板字符串\r\n     * @returns AST对象数组\r\n     */\r\n    static compileTemplateToAst(elementStr) {\r\n        let templateStr = elementStr.trim();\r\n        // 准备栈空间\r\n        let stack1 = [];\r\n        let stack2 = [{ tagName: undefined, children: [], attrs: [] }];\r\n        let index = 0;\r\n        // 开始标签的正则表达式\r\n        let startRegExp = /^\\<(\\s*)([a-z]+[1-6]?|ui\\-[a-z]+[1-6]?)((?:\\s+.+?)*?)(\\s*)\\>/;\r\n        // 匹配结束标签的正则表达式\r\n        let endRegExp = /^\\<(\\s*)\\/(\\s*)([a-z]+[1-6]?|ui\\-[a-z]+[1-6]?)(\\s*)\\>/;\r\n        // 匹配开始标签和结束标签之间的文字的正则表达式 \r\n        let wordRegExp = /^([\\s\\S]+?)(?=\\<(\\s*)\\/?(\\s*)(?:[a-z]+[1-6]?|ui\\-[a-z]+[1-6]?)((?:\\s+.+?)*?)(\\s*)\\>)/;\r\n        // 匹配裸字符串，全字符匹配配合wordRegExp标签判断是不是裸字符串\r\n        let onlyWordRegExp = /^([\\s\\S]+)/;\r\n        // 匹配注释\r\n        let commentRegExp = /^\\<!--[\\s\\S]+?--\\>/;\r\n        // pre结束标签。\r\n        let preEndTagRegExp = /^([\\s\\S]+)(?=\\<(\\s*)\\/(\\s*)pre(?:\\s.+?)?(\\s*)\\>)/;\r\n        // pre标签标志，遇到pre标签要把标签里面的内容当成文本节点。\r\n        let preFlag = false;\r\n        // 匹配到字符串末尾\r\n        while (index < templateStr.length - 1) {\r\n            let rest = templateStr.substring(index);\r\n            if (preFlag) {\r\n                // 现在进入到pre标签里面了 直接搜索</pre>结束标签\r\n                let text = rest.match(preEndTagRegExp) ? rest.match(preEndTagRegExp)[1] : null;\r\n                if (text) {\r\n                    stack2[stack2.length - 1].children.push({ textContent: text, tagName: 'text' });\r\n                    index += text.length;\r\n                    preFlag = false;\r\n                }\r\n                else {\r\n                    throw new Error(\"pre标签未闭合\");\r\n                }\r\n            }\r\n            else if (startRegExp.test(rest)) {\r\n                // 识别遍历到的字符是不是一个开始标签\r\n                // beforeSpaceString:左尖括号与标签名之间的空格\r\n                // tagName:标签名  \r\n                // attrString:标签里的属性字符串 \r\n                // afterSpaceString:属性与右尖括号之间的空格\r\n                let [, beforeSpaceString, tagName, attrString, afterSpaceString] = rest.match(startRegExp);\r\n                const beforeSpaceLenght = beforeSpaceString ? beforeSpaceString.length : 0;\r\n                const tagNameLenght = tagName ? tagName.length : 0;\r\n                const atttLenght = attrString ? attrString.length : 0;\r\n                const afterSpaceLenght = afterSpaceString ? afterSpaceString.length : 0;\r\n                if (tagName === 'pre') {\r\n                    // pre标签\r\n                    preFlag = true;\r\n                }\r\n                if (selfClosingTag.indexOf(tagName) !== -1) {\r\n                    // 这个标签是自闭合标签\r\n                    stack2[stack2.length - 1].children.push({\r\n                        tagName,\r\n                        children: [],\r\n                        attrs: this.parseAttrString(attrString)\r\n                    });\r\n                }\r\n                else {\r\n                    // 这个标签是普通的标签\r\n                    // 开始标签入栈\r\n                    stack1.push(tagName);\r\n                    // AST入栈\r\n                    stack2.push({\r\n                        tagName,\r\n                        children: [],\r\n                        attrs: this.parseAttrString(attrString)\r\n                    });\r\n                    // 需要跳过的长度 = 2个尖括号 + 左尖括号与标签名之间的空格长度 + 标签名长度 + 属性长度 + 属性与右尖括号之间的空格长度\r\n                    index += 2 + beforeSpaceLenght + tagNameLenght + atttLenght + afterSpaceLenght;\r\n                }\r\n            }\r\n            else if (endRegExp.test(rest)) {\r\n                // 识别结束标记\r\n                // let tagName = rest.match(endRegExp)[1];\r\n                // beforeSpaceString: / 之前的空格\r\n                // afterSpaceString: / 之后的空格\r\n                // tagName: 标签名字\r\n                // endSpaceString: 标签之后的空格\r\n                let [, beforeSpaceString, afterSpaceString, tagName, endSpaceString] = rest.match(endRegExp);\r\n                const beforeSpaceLenght = beforeSpaceString ? beforeSpaceString.length : 0;\r\n                const afterSpaceLenght = afterSpaceString ? afterSpaceString.length : 0;\r\n                const tagNameLenght = tagName ? tagName.length : 0;\r\n                const endSpaceLenght = endSpaceString ? endSpaceString.length : 0;\r\n                // 这时候tag一定和栈顶是相同的，因为html需要闭合，如果不相同哪么说明有标签没闭合\r\n                if (tagName != stack1[stack1.length - 1]) {\r\n                    throw new Error(stack1[stack1.length - 1] + \"标签没有封闭\");\r\n                }\r\n                else {\r\n                    stack1.pop();\r\n                    let pop_arr = stack2.pop();\r\n                    if (stack2.length > 0) {\r\n                        stack2[stack2.length - 1].children.push(pop_arr);\r\n                    }\r\n                }\r\n                index += beforeSpaceLenght + afterSpaceLenght + tagNameLenght + endSpaceLenght + 3;\r\n            }\r\n            else if (commentRegExp.test(rest)) {\r\n                // 识别注释\r\n                index += rest.match(commentRegExp)[0].length;\r\n            }\r\n            //wordRegExp.test(rest)   rest.match(wordRegExp) || rest.match(onlyWordRegExp)\r\n            else if (rest.match(wordRegExp) || rest.match(onlyWordRegExp)) {\r\n                //识别为文本节点 \r\n                // wordRegExp 匹配标签前面的字符，如果字符后面没有标签，匹配结果是null\r\n                //当wordRegExp匹配结果是null的时候说明再节点之后有一个裸文本标签（由onlyWordRegExp匹配）\r\n                //再处理之前我们要判断一下当前栈1是否为空，防止有标签没闭合的情况。\r\n                if (!rest.match(wordRegExp) && rest.match(onlyWordRegExp)) {\r\n                    //这里要处理一下可能标签没闭合 如:<div>123\r\n                    if (stack1.length !== 0) {\r\n                        throw new Error(stack1[stack1.length - 1] + '标签没闭合');\r\n                    }\r\n                }\r\n                // 这里要把裸字符串的情况与后面有标签的字符串（标签之间的字符串）分开处理\r\n                let word = rest.match(wordRegExp) ? rest.match(wordRegExp)[1] : rest.match(onlyWordRegExp)[1];\r\n                // 看word是不是全是空\r\n                if (!/^\\s+$/.test(word)) {\r\n                    // 不全是空\r\n                    // 改变栈顶元素\r\n                    // 编译一下看是否有双大括号表达式\r\n                    let expr = this.compileExpression(word);\r\n                    if (typeof expr === 'string') {\r\n                        // 返回的是字符串说明没有双大括号表达式，把属性放进textContent\r\n                        stack2[stack2.length - 1].children.push({ textContent: expr, tagName: 'text' });\r\n                    }\r\n                    else {\r\n                        // 返回的是数组说明是有双大括号表达式的，编译了之后放进expressions属性\r\n                        stack2[stack2.length - 1].children.push({ expressions: expr, tagName: 'text' });\r\n                    }\r\n                }\r\n                index += word.length;\r\n            }\r\n            else {\r\n                // 这里处理一下只有纯文本的形式\r\n                index++;\r\n            }\r\n        }\r\n        return stack2[0].children;\r\n    }\r\n    /**\r\n     * 处理表达式串\r\n     * @param exprStr   含表达式的串\r\n     * @return          处理后的字符串和表达式数组\r\n     */\r\n    static compileExpression(exprStr) {\r\n        if (/\\{\\{.+?\\}\\}/.test(exprStr) === false) {\r\n            return exprStr;\r\n        }\r\n        let reg = /\\{\\{.+?\\}\\}/g;\r\n        let retA = new Array();\r\n        let re;\r\n        let oIndex = 0;\r\n        while ((re = reg.exec(exprStr)) !== null) {\r\n            let ind = re.index;\r\n            //字符串\r\n            if (ind > oIndex) {\r\n                let s = exprStr.substring(oIndex, ind);\r\n                retA.push(s);\r\n            }\r\n            //实例化表达式对象\r\n            let exp = new Expression(re[0].substring(2, re[0].length - 2));\r\n            //加入工厂\r\n            retA.push(exp);\r\n            oIndex = ind + re[0].length;\r\n        }\r\n        //最后的字符串\r\n        if (oIndex < exprStr.length - 1) {\r\n            retA.push(exprStr.substr(oIndex));\r\n        }\r\n        return retA;\r\n    }\r\n}\r\n// /**\r\n//  * 编译器，负责模版的编译\r\n//  * @since 1.0\r\n//  */\r\n// export  class Compiler {\r\n//     /**\r\n//      * 编译\r\n//      * 如果为el.innerHTML方式，可能存在多个子节点，则在外面包一层父节点，因为模块只能有一个根节点，否则返回模块根节点\r\n//      * @param elementStr    待编译html串\r\n//      * @returns             虚拟dom\r\n//      */\r\n//     public static compile(elementStr:string):Element {\r\n//         const div:HTMLElement = Util.newEl('div');\r\n//         try{\r\n//             div.innerHTML = elementStr;\r\n//         }catch(e){}\r\n//         let oe = new Element('div');\r\n//         oe.setProp('role','moduleContainer')\r\n//         this.handleChildren(oe,div);\r\n//         // //保证模块只有一个根节点\r\n//         // if(oe.children.length===1){\r\n//         //     return oe.children[0];\r\n//         // }\r\n//         return oe;\r\n//     }\r\n//     /**\r\n//      * 编译dom\r\n//      * @param ele           待编译html element\r\n//      * @param parent        父节点（virtualdom）   \r\n//      */\r\n//     public static compileDom(ele:Node) {\r\n//         let oe:Element;\r\n//         //注视标志\r\n//         let isComment = false;\r\n//         switch (ele.nodeType) {\r\n//         case Node.ELEMENT_NODE: //元素\r\n//             let el:HTMLElement = <HTMLElement>ele;\r\n//             oe = this.handleDefineEl(el);\r\n//             if(!oe){\r\n//                 oe = this.handleEl(el);\r\n//             }\r\n//             break;\r\n//         case Node.TEXT_NODE: //文本节点\r\n//             oe = new Element();\r\n//             let txt = ele.textContent;\r\n//             let expA = this.compileExpression(txt);\r\n//             if (typeof expA === 'string') { //无表达式\r\n//                 oe.textContent = expA;\r\n//             } else { //含表达式\r\n//                 oe.expressions = expA;\r\n//             }\r\n//             break;\r\n//         case Node.COMMENT_NODE: //注释\r\n//             isComment = true;\r\n//             break;\r\n//         }\r\n//         //添加到子节点,comment节点不需要    \r\n//         if (!isComment) {\r\n//             return oe;\r\n//         }\r\n//     }\r\n//     /**\r\n//      * 编译html element\r\n//      * @param oe    新建的虚拟dom\r\n//      * @returns     虚拟dom\r\n//      */\r\n//     public static handleEl(el:HTMLElement):Element{\r\n//         let oe:Element = new Element(el.tagName);\r\n//         this.handleAttributes(oe,el);\r\n//         this.handleChildren(oe,el);\r\n//         return oe;\r\n//     }\r\n//     /**\r\n//      * 编译插件\r\n//      * @param el 待处理的html element\r\n//      * @returns  如果识别自定义el，则返回编译后的虚拟dom，否则返回undefined\r\n//      */\r\n//     static handleDefineEl(el:HTMLElement):Element{\r\n//         let de:any = PluginManager.get(el.tagName);\r\n//         if(!de){\r\n//             return;\r\n//         }\r\n//         return Reflect.construct(de,[el]).element;\r\n//     }\r\n//     /**\r\n//      * 处理属性\r\n//      * @param oe 新建的虚拟dom\r\n//      * @param el 待处理的html element\r\n//      */\r\n//     public static handleAttributes(oe:Element,el:HTMLElement){\r\n//         //遍历attributes\r\n//         //先处理普通属性，再处理指令\r\n//         let directives = [];\r\n//         for (let i = 0; i < el.attributes.length; i++) {\r\n//             let attr = el.attributes[i];\r\n//             if (attr.name.startsWith('x-')) { //指令，先存，最后处理\r\n//                 directives.push(attr);\r\n//             } else if (attr.name.startsWith('e-')) { //事件\r\n//                 let en = attr.name.substr(2);\r\n//                 oe.addEvent(new NEvent(en, attr.value.trim()));\r\n//             } else {\r\n//                 let isExpr:boolean = false;\r\n//                 let v = attr.value.trim();\r\n//                 if (v !== '') {\r\n//                     let ra = this.compileExpression(v);\r\n//                     if (Util.isArray(ra)) {\r\n//                         oe.setProp(attr.name, ra,true);\r\n//                         isExpr = true;\r\n//                     }\r\n//                 }\r\n//                 if (!isExpr) {\r\n//                     oe.setProp(attr.name, v);\r\n//                 }\r\n//             }\r\n//         }\r\n//         //处理属性\r\n//         for(let attr of directives){\r\n//             new Directive(attr.name.substr(2), attr.value.trim(),oe,null,true);\r\n//         }\r\n//         if(directives.length>1){\r\n//             //指令排序\r\n//             oe.directives.sort((a, b) => {\r\n//                 return a.type.prio - b.type.prio;\r\n//             });    \r\n//         }\r\n//     }\r\n//     /**\r\n//      * 处理子节点\r\n//      * @param oe 新建的虚拟dom\r\n//      * @param el 待处理的html element\r\n//      */\r\n//     public static handleChildren(oe:Element,el:HTMLElement){\r\n//         //子节点编译\r\n//         for(let i=0;i<el.childNodes.length;i++){\r\n//             let nd = el.childNodes[i];\r\n//             let o = this.compileDom(nd);\r\n//             if(o){\r\n//                 if(o.tagName && oe.isSvgNode){ //设置svg对象\r\n//                     o.isSvgNode = true;\r\n//                 }\r\n//                 oe.children.push(o);\r\n//             }\r\n//         }\r\n//     }\r\n//     /**\r\n//      * 处理表达式串\r\n//      * @param exprStr   含表达式的串\r\n//      * @return          处理后的字符串和表达式数组\r\n//      */\r\n//     private static compileExpression(exprStr:string):string|any[] {\r\n//         if (/\\{\\{.+?\\}\\}/.test(exprStr) === false) {\r\n//             return exprStr;\r\n//         }\r\n//         let reg:RegExp = /\\{\\{.+?\\}\\}/g;\r\n//         let retA = new Array();\r\n//         let re:RegExpExecArray;\r\n//         let oIndex:number = 0;\r\n//         while ((re = reg.exec(exprStr)) !== null) {\r\n//             let ind = re.index;\r\n//             //字符串\r\n//             if (ind > oIndex) {\r\n//                 let s = exprStr.substring(oIndex, ind);\r\n//                 retA.push(s);\r\n//             }\r\n//             //实例化表达式对象\r\n//             let exp = new Expression(re[0].substring(2, re[0].length - 2));\r\n//             //加入工厂\r\n//             retA.push(exp);\r\n//             oIndex = ind + re[0].length;\r\n//         }\r\n//         //最后的字符串\r\n//         if (oIndex < exprStr.length - 1) {\r\n//             retA.push(exprStr.substr(oIndex));\r\n//         }\r\n//         return retA;\r\n//     }\r\n// }\r\n//# sourceMappingURL=compiler.js.map","references":["D:/Git/git_repos/nodom2.1/core/directive.ts","D:/Git/git_repos/nodom2.1/core/element.ts","D:/Git/git_repos/nodom2.1/core/event.ts","D:/Git/git_repos/nodom2.1/core/expression.ts","D:/Git/git_repos/nodom2.1/core/pluginmanager.ts","D:/Git/git_repos/nodom2.1/core/types.ts","D:/Git/git_repos/nodom2.1/core/util.ts"],"map":"{\"version\":3,\"file\":\"compiler.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../core/compiler.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"D:/Git/git_repos/nodom2.1/node_modules/.cache/rollup-plugin-typescript2/placeholder/core/compiler.d.ts","writeByteOrderMark":false,"text":"import { Element } from \"./element\";\r\nexport declare class Compiler {\r\n    /**\r\n    * 编译\r\n    * @param elementStr    待编译html串\r\n    * @returns             虚拟dom\r\n    */\r\n    static compile(elementStr: string): Element;\r\n    /**\r\n     * 把AST编译成虚拟dom\r\n     * @param oe 虚拟dom的根容器\r\n     * @param ast 抽象语法树也就是JSON对象\r\n     * @returns oe 虚拟dom的根容器\r\n     */\r\n    private static compileAST;\r\n    /**\r\n     * 编译text类型的ast到虚拟dom\r\n     * @param parent 父虚拟dom节点\r\n     * @param ast 虚拟dom树\r\n     */\r\n    private static handleAstText;\r\n    /**\r\n     *\r\n     * @param oe 虚拟dom\r\n     * @param astObj\r\n     */\r\n    private static handleAstNode;\r\n    /**\r\n     * 编译ast 到虚拟dom\r\n     * @param oe 虚拟dom\r\n     * @param attrs 需要编译成虚拟dom的attrs\r\n     */\r\n    private static handleAstAttrs;\r\n    /**\r\n     * 处理属性字符串\r\n     * @param attrString 属性字符串\r\n     * @returns attrs数组\r\n     */\r\n    private static parseAttrString;\r\n    /**\r\n     * 将模板字符串转换成AST抽象语法树结构\r\n     * @param elementStr 模板字符串\r\n     * @returns AST对象数组\r\n     */\r\n    private static compileTemplateToAst;\r\n    /**\r\n     * 处理表达式串\r\n     * @param exprStr   含表达式的串\r\n     * @return          处理后的字符串和表达式数组\r\n     */\r\n    private static compileExpression;\r\n}\r\n"}}
